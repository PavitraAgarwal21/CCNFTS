// mod NFTContract ;
// pub mod chess_test;
// pub mod ERC721Contract;
// pub mod BoardNFT ;

mod MoveNFT;
// use chess_test::{generateMoves, searchMove, negMax, MoveArray, ArrayStack, working_with_array , isLegalMove };
// use alexandria_encoding::base64::Base64UrlEncoder;
// use alexandria_encoding::base64::Base64Encoder;
// use core::array::ArrayTrait;
// // mod svg {
// //     mod image ; 
// // }

// fn main() {
//     let mut base64u8 = ArrayTrait::<u8>::new();

//     // so what i have to do is to first convert the each into its asic value then convert it into the base64 value encodeing

//     // base64u8.append();

//     println!("Hello, world!");
// }
// fn main() {
// let vale : u256 = 16 ; 
// let val = U256BitShift::shl(vale, 3); // right shift  division  >>
// let valr =U256BitShift::shr(vale, 3); // left shift  multiply << 
/// working with the array 

// let mut vec = Felt252Vec::<u128>::new(); 
//  working_with_array() ;
// println!("{}" , valr );
// println!("{}" , max_u256);
//apply move
// let new_board = applyMove(0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF ,0x1A2 ) ; 
// println!("new12 {}", new_board) ;
// rotate 
// let new_board = rotate(0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF ) ; 
// println!("new12 {}", new_board) ;
// Chprinting() ; 
// negMax(0x3256230011111100000000000000000099999900BCDECB000000001 , 1 ); 
// searchMove(0x3256230011111100000000000000000099999900BCDECB000000001, 0x1A2) ; 
// generateMoves(0x3256230011111100000000000000000099999900BCDECB000000001);

// let mut vec: Felt252Vec<u128> = Felt252Vec::<u128> { items: Default::default(), len: 0 };
// let movearray = MoveArray { index: 0, items: vec, };
// working_with_array();
//generateMoves(0x3256230011111100000000000000000099999900BCDECB000000001);
// appendTo(movearray, 0xA12, 0x1A2);
//  let vec = Felt252Vec::<u128>::new() ; 

// }


